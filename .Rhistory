legend.text = element_text(size = 14), # Adjust font size for legend text
legend.title = element_text(size = 14) # Adjust font size for legend title
)
#### F2 ####
plot5 <- ggplot(unique_data, aes(x = "", y = sF2_mean_unique, fill = interval)) +
# clouds
introdataviz::geom_flat_violin(trim=FALSE, alpha = 0.4,
position = position_nudge(x = rain_height+.05)) +
# rain
geom_point(aes(colour = interval), size = 2, alpha = .5, show.legend = FALSE,
position = position_jitter(width = rain_height, height = 0)) +
# boxplots
geom_boxplot(width = rain_height, alpha = 0.4, show.legend = FALSE,
outlier.shape = NA,
position = position_nudge(x = -rain_height*2), aes(x = 0.95 + stagger_offsets[as.numeric(factor(interval))])) +
# coord_flip() +
# mean and SE point in the cloud
# stat_summary(fun.data = mean_cl_normal, mapping = aes(color = interval), show.legend = FALSE,
#              position = position_nudge(x = rain_height * 3)) +
# adjust layout
scale_x_discrete(name = "", expand = c(rain_height*3, 0, 0, 0.7)) +
scale_y_continuous(name = "F2 (Hz)",
# breaks = seq(-30, 2, 30),
# limits = c(-30, 30)) +
) +
coord_flip() +
# facet_wrap(~factor(facet_contrast,
#                    levels = c("vcl", "v"),
#                    labels = c("h - ħ", "ʔ - ʕ")),
#            nrow = 2) +
# custom colours and theme
scale_fill_brewer(palette = "Dark2", name = "Contrast Type") +
scale_colour_brewer(palette = "Dark2") +
theme_minimal() +
theme(panel.grid.major.y = element_blank(),
legend.position.inside = c(0.9, 0.9),
legend.background = element_rect(fill = "white", color = "white"))
#### HNR05 ####
plot6 <- ggplot(unique_data, aes(x = "", y = HNR05_mean_unique, fill = interval)) +
# clouds
introdataviz::geom_flat_violin(trim=FALSE, alpha = 0.4,
position = position_nudge(x = rain_height+.05)) +
# rain
geom_point(aes(colour = interval), size = 2, alpha = .5, show.legend = FALSE,
position = position_jitter(width = rain_height, height = 0)) +
# boxplots
geom_boxplot(width = rain_height, alpha = 0.4, show.legend = FALSE,
outlier.shape = NA,
position = position_nudge(x = -rain_height*2), aes(x = 0.95 + stagger_offsets[as.numeric(factor(interval))])) +
# coord_flip() +
# mean and SE point in the cloud
# stat_summary(fun.data = mean_cl_normal, mapping = aes(color = interval), show.legend = FALSE,
#              position = position_nudge(x = rain_height * 3)) +
# adjust layout
scale_x_discrete(name = "", expand = c(rain_height*3, 0, 0, 0.7)) +
scale_y_continuous(name = "HNR05 (dB)",
# breaks = seq(-30, 2, 30),
# limits = c(-30, 30)) +
) +
coord_flip() +
# facet_wrap(~factor(facet_contrast,
#                    levels = c("vcl", "v"),
#                    labels = c("h - ħ", "ʔ - ʕ")),
#            nrow = 2) +
# custom colours and theme
scale_fill_brewer(palette = "Dark2", name = "Contrast Type") +
scale_colour_brewer(palette = "Dark2") +
theme_minimal() +
theme(panel.grid.major.y = element_blank(),
legend.position.inside = c(0.9, 0.9),
legend.background = element_rect(fill = "white", color = "white"))
#### Residual H1* ####
plot7 <- ggplot(unique_data, aes(x = "", y = H1c.resid_mean_unique, fill = interval)) +
# clouds
introdataviz::geom_flat_violin(trim=FALSE, alpha = 0.4,
position = position_nudge(x = rain_height+.05)) +
# rain
geom_point(aes(colour = interval), size = 2, alpha = .5, show.legend = FALSE,
position = position_jitter(width = rain_height, height = 0)) +
# boxplots
geom_boxplot(width = rain_height, alpha = 0.4, show.legend = FALSE,
outlier.shape = NA,
# position = position_nudge(x = -rain_height*2) +
position = position_nudge(x = -rain_height*2), aes(x = 0.95 + stagger_offsets[as.numeric(factor(interval))])) +
# coord_flip() +
# mean and SE point in the cloud
# stat_summary(fun.data = mean_cl_normal, mapping = aes(color = interval), show.legend = FALSE,
#              position = position_nudge(x = rain_height * 3)) +
# adjust layout
scale_x_discrete(name = "", expand = c(rain_height*3, 0, 0, 0.7)) +
scale_y_continuous(name = "SoE (dB)",
# breaks = seq(-30, 2, 30),
# limits = c(-30, 30)) +
) +
coord_flip() +
# facet_wrap(~factor(facet_contrast,
#                    levels = c("vcl", "v","son"),
#                    labels = c("ħ", "ʕ","j/w")),
#            nrow = 1) +
# custom colours and theme
scale_fill_brewer(palette = "Dark2", name = "Segment") +
scale_colour_brewer(palette = "Dark2") +
theme_minimal() +
theme(panel.grid.major.y = element_blank(),
legend.position.inside = c(0.9, 0.8),
legend.background = element_rect(fill = "white", color = "white"),
axis.title.x = element_text(size = 18), # Adjust font size for y-axis labels
axis.text.x = element_text(size = 14), # Adjust font size for x-axis tick labels
legend.text = element_text(size = 14), # Adjust font size for legend text
legend.title = element_text(size = 14) # Adjust font size for legend title
)
grid.arrange(
plot1, plot2, plot3, plot4,
ncol = 2, nrow = 2,
top = grid::textGrob("Acoustic Feature Means for Pharyngeal and Sonorant Consonants", gp=grid::gpar(fontsize=20))
)
subset_mean %>%
#filter(str_outlier=="OK") %>%
filter(tier=="V-sequence") %>%
ggplot(aes(t_prop, CPP, color = interval)) +
geom_smooth(method = "loess", alpha=0.25) +
scale_color_manual(name = NULL, values = ms_colors)+
theme_bw(base_size = 18)+
scale_x_continuous(limits=c(0,1))+
theme(legend.position = "top")+
# facet_wrap(~tier.V-sequence) +
labs(x = "Proportion of vowel duration", y = "CPP (dB)")
unique(subset_mean$tier)
unique(data$tier)
subset
unique(subset_mean$tier)
subset$tier
unique(subset$tier)
subset_mean %>%
filter(tier == "glottis") %>%
View()
### subsetting laryngeal and pharyngeal
subset = subset(data, interval == 'ħ' | interval == 'ʕ' | interval == 'h' | interval == 'ʔ')
# temporarily show any weird rows and then filter for only the phonetic tier
# show the glottis rows (just to inspect)
subset_mean %>%
filter(tier == "glottis") %>%
View()   # or print(), head(), etc.
# keep only phonetic rows
subset_mean <- subset_mean %>%
filter(tier == "phonetic")
### susbetting for plots below based on sonorants
sonorant_subset = subset(data, interval == 'w' | interval == 'j')
#
# sonorant_subset <- sonorant_subset %>%
#   mutate(facet_contrast = "Sonorant /j w/")
#
# subset <- subset %>%
#   mutate(facet_contrast = ifelse(grepl("ħ", interval), "/ħ/", "/ʕ/"))
#
subset <- rbind(subset, sonorant_subset)
##### Data Cleaning for PharyLary
#### author: ben lang, blang@ucsd.edu
# library(lmerTest)
library(plyr)
library(dplyr) # this checks for normality
# library(ggpubr) # this plots normality
library(magrittr)
# library(effects)
library(ggplot2)
# library(ggsignif)
library(tidyr)
# library(scales)
# library(reshape2)
library(lme4)
library(lmerTest)
# library(mgcv)
# library(emmeans)
#library(forcats)
# library(psycho)
# library(janitor)
#library(data.table)
# library(psyphy)
# library("cowplot")
# library("forcats")
# library("optimx")
# library("rlang")
# library("scales")
# library("splines")
library("stringr")
library("tidyverse")
# library("devtools")
# library(grid)
# library(gridExtra)
# orig_data_path <- sprintf('/Volumes/circe/alldata/dissertation/vs/output_preproc/preproc_output.csv')
# orig_data_path <- sprintf('/Volumes/cassandra/alldata/dissertation/vs/output_preproc/preproc_output.csv')
# orig_data_path <- sprintf('/Users/bcl/Desktop/preproc_output.csv')
# orig_data = read.csv(orig_data_path)
### data for the intervals as extracted from overlap with tier 3 because there's no unique labels in tier 1
# data_path <- sprintf('/Volumes/circe/alldata/dissertation/vs/output_preproc/preproc_matchesformeans.csv')
data_path <- sprintf('/Volumes/cassandra/alldata/dissertation/vs/output_preproc/preproc_matchesformeans.csv')
# data_path <- sprintf('/Users/bcl/Desktop/preproc_matchesformeans.csv')
data = read.csv(data_path)
### subsetting laryngeal and pharyngeal
subset = subset(data, interval == 'ħ' | interval == 'ʕ' | interval == 'h' | interval == 'ʔ')
# temporarily show any weird rows and then filter for only the phonetic tier
# show the glottis rows (just to inspect)
subset_mean %>%
filter(tier == "glottis") %>%
View()   # or print(), head(), etc.
# keep only phonetic rows
subset_mean <- subset_mean %>%
filter(tier == "phonetic")
# subset = subset(data, interval == 'ħ' | interval == 'ʕ' | interval == 'h' | interval == 'ʔ')
# subset = subset(data, interval == 'ħ' | interval == 'ʕ')
# subset = subset(subset, Contrast_.IPA. == 'h - ħ' | Contrast_.IPA. == 'ʔ - ʕ')
### susbetting for plots below based on sonorants
sonorant_subset = subset(data, interval == 'w' | interval == 'j')
#
# sonorant_subset <- sonorant_subset %>%
#   mutate(facet_contrast = "Sonorant /j w/")
#
# subset <- subset %>%
#   mutate(facet_contrast = ifelse(grepl("ħ", interval), "/ħ/", "/ʕ/"))
#
subset <- rbind(subset, sonorant_subset)
### remove f0 outliers
## Calculate mean and standard deviation for each participant
# subset_mean <- subset_mean %>%
#   group_by(participant) %>%
#   mutate(strF0_mean = mean(strF0, na.rm = TRUE), strF0_sd = sd(strF0, na.rm = TRUE)) %>%
#   ungroup()
# Filter out rows where f0 is outside the range of 2.5 standard deviations from the mean
# subset_mean_harmonics <- subset_mean %>%
#   filter(strF0 >= (strF0_mean - 3 * strF0_sd) & strF0 <= (strF0_mean + 3 * strF0_sd))
subset = subset %>%
group_by(participant) %>%
mutate(strF0z = (strF0 - mean(strF0, na.rm = T))/sd(strF0, na.rm = T)) %>%
ungroup()
subset = subset %>%
mutate(str_outlier = if_else(abs(strF0z) > 3, "outlier", "OK"))
### flagging formant outliers
### Calculate Mahalanobis distance for formants
vmahalanobis = function (dat) {
if (nrow(dat) < 25) {
dat$zF1F2 = NA
return(dat)
}
means = c(mean(dat$sF1, na.rm=T), mean(dat$sF2, na.rm=T))
cov = cov(cbind(dat$sF1, dat$sF2))
dat$zF1F2 = mahalanobis(cbind(dat$sF1, dat$sF2),
center=means, cov=cov)
dat
}
# Distance larger than 6 is considered as outlier    #MG: smaller numbers = more outliers. The paper I linked to uses 4.
distance_cutoff = 6
# Perform Mahalanobis on dataset
subset =  subset %>%                 #MG: this was cut from a dataset called "tot_fin"
group_by(interval) %>%
do(vmahalanobis(.)) %>%
ungroup() %>%
mutate(formant_outlier = NA)
# Visualize the formants with flagged values
subset %>%
filter(is.na(formant_outlier)) %>%
ggplot(aes(x = sF2, y = sF1, color = zF1F2 > distance_cutoff)) +       #MG: sF2 and sF1 = Snack values from VS
geom_point(size = 0.6) +
facet_wrap(.~interval)+
scale_y_reverse(limits = c(2000,0),position = "right") +
scale_x_reverse(limits = c(3500,0),position = "top")+
theme_bw()
# Tag flagged values
for (i in 1:nrow(subset)) {
if (!is.na(subset$zF1F2[i])) {
if (subset$zF1F2[i] > distance_cutoff){
subset$formant_outlier[i] = "outlier"
}
}
}
# Visualize the vowel formant after exclusion
subset %>%
filter(is.na(formant_outlier)) %>%
ggplot(aes(x = sF2, y = sF1)) +
geom_point(size = 0.6) +
#geom_text()+
facet_wrap(.~interval)+
#geom_density_2d() +
#  scale_color_manual(values=c('#a6611a','#dfc27d','#018571'))+
scale_y_reverse(limits = c(2000,0),position = "right") +
scale_x_reverse(limits = c(3500,0),position = "top")+
theme_bw()
#### Formant normalization
### Delta-F method for normalizing VT length (Johnson 2020)
subset = subset %>%
rowwise() %>%
mutate(DF = mean(c(sF1/0.5, sF2/1.5, sF3/2.5)),
F1n = sF1/DF,
F2n = sF2/DF,
F3n = sF3/DF)
### Calculate H1res (residual H1c)
# subset <- subset %>% group_by(participant, phrase, interval) %>% mutate(H1cz = H1c - mean(H1c, na.rm = TRUE))
# subset <- subset %>% group_by(participant, phrase, interval) %>% mutate(energyz = Energy - mean(Energy, na.rm = TRUE))
# mod_h1 <- lmer(H1c ~ energy + (energyz||participant), data = subset, REML = FALSE)
#
# energy.factor = fixef(mod_h1)[2]
#
# subset$H1c.resid = subset$H1cz - subset$energyz * energy.factor
# 1) Diagnose the problem quickly
c(
H1c_nonfinite   = sum(!is.finite(subset$H1c)),
Energy_NA       = sum(is.na(subset$Energy)),
Energy_nonfinite= sum(!is.finite(subset$Energy)),
Energy_le0      = sum(subset$Energy <= 0, na.rm = TRUE)
)
# 2) Clean + prepare model frame
H1c_mod_dat <- subset %>%
mutate(
participant = as.factor(participant),
logEnergy   = log(Energy)
) %>%
filter(
is.finite(H1c),
is.finite(logEnergy),   # drops NA/NaN/Inf, e.g., Energy <= 0 or NA
Energy >= 0
)
summary(lmer(H1c~log(Energy)+(log(Energy)|participant), H1c_mod_dat)) #beta = 5.7206, model does not converge
subset = subset %>%
rowwise() %>%
mutate(H1res = H1c - 5.7206*(log(Energy))
)
## calculate mean values for all intervals in each word for each participant
subset_mean <- subset %>% group_by(participant,phrase,interval) %>% mutate(strF0_mean = mean(strF0, na.rm = TRUE))
subset_mean <- subset_mean %>% group_by(participant,phrase,interval) %>% mutate(strF0z_mean = mean(strF0z, na.rm = TRUE))
subset_mean <- subset_mean %>% group_by(participant,phrase,interval) %>% mutate(H1H2c_mean = mean(H1H2c, na.rm = TRUE))
subset_mean <- subset_mean %>% group_by(participant,phrase,interval) %>% mutate(CPP_mean = mean(CPP, na.rm = TRUE))
subset_mean <- subset_mean %>% group_by(participant,phrase,interval) %>% mutate(soe_mean = mean(soe, na.rm = TRUE))
subset_mean <- subset_mean %>% group_by(participant,phrase,interval) %>% mutate(sF1_mean = mean(sF1, na.rm = TRUE))
subset_mean <- subset_mean %>% group_by(participant,phrase,interval) %>% mutate(sF2_mean = mean(sF2, na.rm = TRUE))
subset_mean <- subset_mean %>% group_by(participant,phrase,interval) %>% mutate(sF3_mean = mean(sF3, na.rm = TRUE))
subset_mean <- subset_mean %>% group_by(participant,phrase,interval) %>% mutate(F1n_mean = mean(F1n, na.rm = TRUE))
subset_mean <- subset_mean %>% group_by(participant,phrase,interval) %>% mutate(F2n_mean = mean(F2n, na.rm = TRUE))
subset_mean <- subset_mean %>% group_by(participant,phrase,interval) %>% mutate(F3n_mean = mean(F3n, na.rm = TRUE))
subset_mean <- subset_mean %>% group_by(participant,phrase,interval) %>% mutate(HNR05_mean = mean(HNR05, na.rm = TRUE))
subset_mean <- subset_mean %>% group_by(participant,phrase,interval) %>% mutate(H1c_mean = mean(H1c, na.rm = TRUE))
subset_mean <- subset_mean %>% group_by(participant,phrase,interval) %>% mutate(H1res_mean = mean(H1res, na.rm = TRUE))
# Histogram of raw Energy values
ggplot(subset_mean, aes(x = Energy)) +
geom_histogram(aes(y = ..density..), binwidth = 0.5, colour = "black", fill = "white") +
geom_density(alpha = .2, fill = "#FF6666") +
labs(title = "Histogram of Energy", x = "Energy", y = "Density")
# Histogram of log-transformed Energy values
ggplot(subset_mean, aes(x = log(Energy))) +
geom_histogram(aes(y = ..density..), binwidth = 0.5, colour = "black", fill = "white") +
geom_density(alpha = .2, fill = "#FF6666") +
labs(title = "Histogram of log-transformed Energy", x = "Log(Energy)", y = "Density")
merged_df <- data %>%
left_join(subset_mean, by = c("participant", "interval", "tier"))
intersect(names(data), names(subset_mean))
View(data)
merged_df <- data %>%
left_join(subset_mean, by = c("participant", "interval", "tier","phrase"))
merged_df <- data %>%
left_join(subset_mean, by = c("participant", "interval", "tier","phrase"), relationship='many-to-many')
merged_df <- data %>%
left_join(subset_mean, by = c("Filename","participant", "interval", "tier","phrase"))
### subsetting laryngeal and pharyngeal
subset = subset(data, interval == 'ħ' | interval == 'ʕ' | interval == 'h' | interval == 'ʔ')
# temporarily show any weird rows and then filter for only the phonetic tier
# show the glottis rows (just to inspect)
subset %>%
filter(tier == "glottis") %>%
View()   # or print(), head(), etc.
# keep only phonetic rows
subset <- subset %>%
filter(tier == "phonetic")
# subset = subset(data, interval == 'ħ' | interval == 'ʕ' | interval == 'h' | interval == 'ʔ')
# subset = subset(data, interval == 'ħ' | interval == 'ʕ')
# subset = subset(subset, Contrast_.IPA. == 'h - ħ' | Contrast_.IPA. == 'ʔ - ʕ')
### susbetting for plots below based on sonorants
sonorant_subset = subset(data, interval == 'w' | interval == 'j')
#
# sonorant_subset <- sonorant_subset %>%
#   mutate(facet_contrast = "Sonorant /j w/")
#
# subset <- subset %>%
#   mutate(facet_contrast = ifelse(grepl("ħ", interval), "/ħ/", "/ʕ/"))
#
subset <- rbind(subset, sonorant_subset)
data = data %>%
group_by(participant) %>%
mutate(strF0z = (strF0 - mean(strF0, na.rm = T))/sd(strF0, na.rm = T)) %>%
ungroup()
data = data %>%
mutate(str_outlier = if_else(abs(strF0z) > 3, "outlier", "OK"))
data = data %>%
filter(interval == 'ħ' | interval == 'ʕ' | interval == 'h' | interval == 'ʔ')
group_by(participant) %>%
mutate(strF0z = (strF0 - mean(strF0, na.rm = T))/sd(strF0, na.rm = T)) %>%
ungroup()
data = data %>%
filter(interval == 'ħ' | interval == 'ʕ' | interval == 'h' | interval == 'ʔ') %>%
group_by(participant) %>%
mutate(strF0z = (strF0 - mean(strF0, na.rm = T))/sd(strF0, na.rm = T)) %>%
ungroup()
data = data %>%
mutate(str_outlier = if_else(abs(strF0z) > 3, "outlier", "OK"))
# data_path <- sprintf('/Volumes/circe/alldata/dissertation/vs/output_preproc/preproc_matchesformeans.csv')
data_path <- sprintf('/Volumes/cassandra/alldata/dissertation/vs/output_preproc/preproc_matchesformeans.csv')
# data_path <- sprintf('/Users/bcl/Desktop/preproc_matchesformeans.csv')
data = read.csv(data_path)
##### Data Cleaning for PharyLary
#### author: ben lang, blang@ucsd.edu
# library(lmerTest)
library(plyr)
library(dplyr) # this checks for normality
# library(ggpubr) # this plots normality
library(magrittr)
# library(effects)
library(ggplot2)
# library(ggsignif)
library(tidyr)
# library(scales)
# library(reshape2)
library(lme4)
library(lmerTest)
# library(mgcv)
# library(emmeans)
#library(forcats)
# library(psycho)
# library(janitor)
#library(data.table)
# library(psyphy)
# library("cowplot")
# library("forcats")
# library("optimx")
# library("rlang")
# library("scales")
# library("splines")
library("stringr")
library("tidyverse")
# library("devtools")
# library(grid)
# library(gridExtra)
# orig_data_path <- sprintf('/Volumes/circe/alldata/dissertation/vs/output_preproc/preproc_output.csv')
# orig_data_path <- sprintf('/Volumes/cassandra/alldata/dissertation/vs/output_preproc/preproc_output.csv')
# orig_data_path <- sprintf('/Users/bcl/Desktop/preproc_output.csv')
# orig_data = read.csv(orig_data_path)
### data for the intervals as extracted from overlap with tier 3 because there's no unique labels in tier 1
# data_path <- sprintf('/Volumes/circe/alldata/dissertation/vs/output_preproc/preproc_matchesformeans.csv')
data_path <- sprintf('/Volumes/cassandra/alldata/dissertation/vs/output_preproc/preproc_matchesformeans.csv')
# data_path <- sprintf('/Users/bcl/Desktop/preproc_matchesformeans.csv')
data = read.csv(data_path)
##### Data Cleaning for PharyLary
#### author: ben lang, blang@ucsd.edu
# library(lmerTest)
library(plyr)
library(dplyr) # this checks for normality
# library(ggpubr) # this plots normality
library(magrittr)
# library(effects)
library(ggplot2)
# library(ggsignif)
library(tidyr)
# library(scales)
# library(reshape2)
library(lme4)
library(lmerTest)
# library(mgcv)
# library(emmeans)
#library(forcats)
# library(psycho)
# library(janitor)
#library(data.table)
# library(psyphy)
# library("cowplot")
# library("forcats")
# library("optimx")
# library("rlang")
# library("scales")
# library("splines")
library("stringr")
library("tidyverse")
# library("devtools")
# library(grid)
# library(gridExtra)
# orig_data_path <- sprintf('/Volumes/circe/alldata/dissertation/vs/output_preproc/preproc_output.csv')
# orig_data_path <- sprintf('/Volumes/cassandra/alldata/dissertation/vs/output_preproc/preproc_output.csv')
# orig_data_path <- sprintf('/Users/bcl/Desktop/preproc_output.csv')
# orig_data = read.csv(orig_data_path)
### data for the intervals as extracted from overlap with tier 3 because there's no unique labels in tier 1
# data_path <- sprintf('/Volumes/circe/alldata/dissertation/vs/output_preproc/preproc_matchesformeans.csv')
data_path <- sprintf('/Volumes/cassandra/alldata/dissertation/vs/output_preproc/preproc_matchesformeans.csv')
# data_path <- sprintf('/Users/bcl/Desktop/preproc_matchesformeans.csv')
data = read.csv(data_path)
library(dplyr)
targets <- c("ħ", "ʕ", "h", "ʔ", "w", "j")
data <- data %>%
group_by(participant) %>%
mutate(
# compute z-scores using only rows where interval is a target AND target_match == 1
.m = mean(strF0[interval %in% targets & target_match == 1], na.rm = TRUE),
.s = sd(  strF0[interval %in% targets & target_match == 1], na.rm = TRUE),
strF0z = if_else(
interval %in% targets & target_match == 1 & is.finite(.s) & .s > 0,
(strF0 - .m) / .s,
NA_real_
)
) %>%
ungroup() %>%
mutate(
str_outlier = if_else(
interval %in% targets & target_match == 1 & is.finite(strF0z) & abs(strF0z) > 3,
"outlier",
if_else(interval %in% targets & target_match == 1, "OK", NA_character_)
)
) %>%
select(-.m, -.s)
